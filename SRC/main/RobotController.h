#pragma once
#include <Adafruit_MotorShield.h>
#include "utility/Adafruit_MS_PWMServoDriver.h"
#include "math.h"


class RobotController {
private:
  Adafruit_MotorShield AFMS;
  
  Adafruit_DCMotor *frontRightMotor;
  Adafruit_DCMotor *frontLeftMotor;
  Adafruit_DCMotor *backLeftMotor;
  Adafruit_DCMotor *backRightMotor;

  float defaultSpeed;

  // Keeping track of current speed as percent
  float leftSideSpeed;
  float rightSideSpeed;

  // Converts a percent (0-1) to 0-255
  int percentToSpeed(float percent) {
    return percent*255;
  }

  void setSpeed(float percent) {
    int speed = percentToSpeed(percent);

    frontRightMotor->setSpeed(speed);
    frontLeftMotor->setSpeed(speed);
    backLeftMotor->setSpeed(speed);
    backRightMotor->setSpeed(speed);
  }

public:
   RobotController(float defaultSpeedPercent, Adafruit_MotorShield motorShield) {
    AFMS = motorShield;
    frontRightMotor = AFMS.getMotor(1);
    frontLeftMotor = AFMS.getMotor(2);
    backLeftMotor = AFMS.getMotor(3);
    backRightMotor = AFMS.getMotor(4);
    defaultSpeed = defaultSpeedPercent;
    leftSideSpeed = defaultSpeed;
    rightSideSpeed = defaultSpeed;
  }

  void begin() {
    AFMS.begin();
  }

  void forward(float speed){
    setSpeed(speed);

    frontRightMotor->run(FORWARD);
    frontLeftMotor->run(FORWARD);
    backLeftMotor->run(FORWARD);
    backRightMotor->run(FORWARD);
  }

  void forward() {
    forward(defaultSpeed);
  }

  void backward(float speed) {
    setSpeed(speed);

    frontRightMotor->run(BACKWARD);
    frontLeftMotor->run(BACKWARD);
    backLeftMotor->run(BACKWARD);
    backRightMotor->run(BACKWARD);
  }

  void backward() {
    backward(defaultSpeed);
  }

  void right(float percentSpeed) {
    rightSideSpeed = percentSpeed;
    int speed = percentToSpeed(percentSpeed);

    frontRightMotor->setSpeed(speed);
    backRightMotor->setSpeed(speed);
    frontRightMotor->run(FORWARD);
    backRightMotor->run(FORWARD);
  }

  void right() {
    right(defaultSpeed);
  }

  void left(float percentSpeed) {
    leftSideSpeed = percentSpeed;
    int speed = percentToSpeed(percentSpeed);

    frontLeftMotor->setSpeed(speed);
    backLeftMotor->setSpeed(speed);
    frontLeftMotor->run(FORWARD);
    backLeftMotor->run(FORWARD);
  }

  void left() {
    left(defaultSpeed);
  }

  void stop() {
    leftSideSpeed = 0.0;
    rightSideSpeed = 0.0;

    frontRightMotor->run(RELEASE);
    frontLeftMotor->run(RELEASE);
    backLeftMotor->run(RELEASE);
    backRightMotor->run(RELEASE);
  }

  // Returns the current speed on the left side as a percentage
  float speedLeft() {
    return leftSideSpeed;
  }

  // Returns the current speed on the right side as a percentage
  float speedRight() {
    return rightSideSpeed;
  }
  float sensor_angle[4] = {
  0.7854,
  0.2618,
  -0.2618,
  -0.7854  
  };
  void ap_lite() {
    int reading_in; // the raw sensor reading AFTER being converted to inches
    int r; // sensor reading, with respect to range?
    float F; // Force 
    float delta; // the change in velocity
    float delta_vx, delta_vy; // change in velocity in each direction
    float w; // Angle of the robot to turn
    float theta; // The sensor angle
    float theta_new;
    float currentVelocity = 0.5;

    // Power and speed are defined as a percentage of the maximum speed (0-1 inclusive)
    int power_left = 0;
    int power_right = 0;
    float STEP = 1.0; // step size of the robot
    float mass = 1.0; // mass of the robot (makes math easier)
    float FR = 0.5; // Friction
    float Fx = 100.0; // attractive goal force in x direction
    float Fy = 0.0; // robot does not move side-ways hence it's 0
    float v = currentVelocity; // current velocity, initial value is 70%
    float vx = FR * v; // velocity drops with friction
    float vy = 0; // no side-ways velocity


    // Changable settings
    float alpha = 1; // decides the amount to turn
    int MAX_SPEED = 60; // maximum power supply to motors 0-100 (converted later)
    int RANGE = 30; // reactive distance to an obstacle
    // Changing these values changes the repulsive force generated by each set of sensors
    float kmid = 7.0; // Hooke's law constant for two middle sensors
    float kside = 5.0; //Hooke's law constant for two outside sensors

    // for (all current sensors)
    for (int i = 0; i < 4; i++) {
      // Algorithm calls for the reading to be converted to inches.
      // Member function "readValue()" already does this.
      // "readValue()" also already filters for low readings.
      reading_in = sensor[i].readValue();
      theta = sensor_angle[i];

      r = RANGE - reading_in;
      if (r < 0) {
        // No obstacles seen
        r = 0;
      }

      // If we are reading from the middle sensors
      if (i == 1 || i == 2) {
        // compute force from the two middle sensors
        F = kmid * r; 
      }
      else {
        // compute force from the two out side sensors
        F = kside * r;
      }

      Fx = Fx - (F * cos(theta)); // Repulsive x component 
      Fy = Fy - (F * sin(theta)); // Repulsive y component    
    }

    delta_vx = STEP * Fx / mass; // change in velocity in x direction
    delta_vy = STEP * Fy / mass; // change in velocity in y direction

    vx += delta_vx; // add to velocity in x direction
    vy += delta_vy; // add to velocity in y direction

    v = sqrt(vx * vx + vy * vy); // current velocity

    delta = atan2(delta_vy, delta_vx); // direction of change in velocity
    w = turn_function(delta); // angle of the robot turn

    currentVelocity = v; // reset current velocity
    float turn_angle;

    turn_angle = atan2(vy, vx); // robot moves in first or second quadrant

    if ((-PI / 2.0 <= turn_angle) && (turn_angle <= PI/2.0)) {
      power_right = (int)(v + v * alpha * w); // power to right motor
      power_left = (int)(v - v * alpha * w); // power to left motor

      // proportionally cap the motor power
      // convert percent speed to integer for comparison
      if (power_right > MAX_SPEED || (int)speedLeft()*100 > MAX_SPEED) {
        if (power_right >= power_left) {
          power_left = MAX_SPEED * power_left / power_right;
          power_right = MAX_SPEED;
        }
        else {
          power_right = MAX_SPEED * power_right / power_left;
          power_left = MAX_SPEED;
        }
      }
    }

    // If power is negative make it 0
    // Change this if you want the wheels to go backwards
    // make sure to add compatbility in the robot controller if you do so
    if (power_left < 0) {
      power_left = 0;
    }
    if (power_right < 0) {
      power_right = 0;
    }

    // Convert int speed to percentage
    left((float)power_left/100);
    right((float)power_right/100);  
  }

  // Return the angle to turn in radians
  float turn_function(float angle) {
    float angle_rad = angle;

    // // robot moving to the first quadrant
    // if ((0 < angle) && (angle <= PI / 2.0)) {
    //   angle_rad = (PI / 2.0) - angle;
    // }
    // robot moving to the second quadrant
    if ((PI / 2.0 < angle) && (angle <= PI)) {
      angle_rad = PI - angle;
    }
    // robot moving to the third quadrant  
    if ((-PI < angle) && (angle <= -PI / 2.0)) {
      angle_rad = -PI - angle; //only used in backward move
    }
    // // robot moving to the fourth quadrant
    // if ((-PI / 2.0 < angle) && (angle <= 0)) {
    //   angle_rad = (-PI / 2.0) - angle;
    // }
    return angle_rad;
    

  };
float previousMillis = 0;
int turn = 0; // 0 = no turn, 1 = left turn, 2 = right turn

void log_turn(float turn) {
  if (turn != 0) {
    float currentMillis = millis();
    Serial.print("Turn ");
    if (turn == 1) {
      Serial.print("left");
    } else if (turn == 2) {
      Serial.print("right");
    }
    Serial.print(" at ");
    Serial.print(currentMillis - previousMillis);
    Serial.println(" ms since last turn");
    previousMillis = currentMillis;
    turn = 0; // reset turn flag
  }
}




};
