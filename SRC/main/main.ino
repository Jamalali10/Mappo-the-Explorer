#include <Adafruit_MotorShield.h>
#include "RobotController.h"
#include "IR.h"
#include <math.h>

float defaultRobotSpeed = 0.70;

// Default velocity set, can change I guess
float currentVelocity = 0.5;

RobotController robot = RobotController(defaultRobotSpeed, Adafruit_MotorShield());

// Sensors must be placed on the robot from left to right (when facing with the direction of travel.
// That is, you're behind the robot) for the ap_lite() algorithm to work.
// A6 is skipped because of the position of the motorboard over the arduino
IR sensor[4] = {
  IR(A0),
  IR(A1),
  IR(A2),
  IR(A3)
};

// The sensor angle in radians. This angle is in respect to the velocity vector drawn when the robot is moving forward.
// Sensor offset degrees from left to right
// 45 degrees, 15 degrees, -15 degrees, -45 degrees
// Index here maps to the appropriate sensor index.
float sensor_angle[4] = {
  0.7854,
  0.2618,
  -0.2618,
  -0.7854  
};

void setup() {
  Serial.begin(9600);
  robot.begin();
}

void loop() {
  //test_function();
  ap_lite();
  //robot.left();
  //Serial.println(sensor[3].readValue());
  delay(1000);
}

/*void plot_points(float sensor_angle, float distance) {
  float theta = TURN_ANGLE + sensor_angle;
  float r = reading/CELL_SIZE;
  float x1 = r * cos(theta);
  float y1 = r * sin(theta);
  // We want to go from where we detected the object, out beyond
  // the table. 
  float x2 = LOCAL_TABLE_SIZE * cos(theta);
  float y2 = LOCAL_TABLE_SIZE * sin(theta);
  float dx = abs(x2 - x1);
  float dy = abs(y2 - y1);
  bool positive_slope = true;

  if (dx > dy) {
    positive_slope = false;
  }

  // pk is initial decision making parameter
	// Note:x1&y1,x2&y2, dx&dy values are interchanged
	// and passed in plotPixel function so
	// it can handle both cases when m>1 & m<1
	int pk = 2 * dy - dx;

  // Makes (0,0) in the cartesian plane map to the center of our table
  int cartesian_offset = LOCAL_TABLE_SIZE/2;
	for (int i = 0; i <= dx; i++) {
		// Increase the hitpoints at the given location in the local map
    localmap[x1 + cartesian_offset][y1 + cartesian_offset] += 1;
		
    // checking either to decrement or increment the
		// value if we have to plot from (0,100) to (100,0)
		x1 < x2 ? x1++ : x1--;
		if (pk < 0) {
			// decision value will decide to plot
			// either x1 or y1 in x's position
			if (decide == 0) {
				// putpixel(x1, y1, RED);
				pk = pk + 2 * dy;
			}
			else {
				//(y1,x1) is passed in xt
				// putpixel(y1, x1, YELLOW);
				pk = pk + 2 * dy;
			}
		}
		else {
			y1 < y2 ? y1++ : y1--;
			if (decide == 0) {

				// putpixel(x1, y1, RED);
			}
			else {
				// putpixel(y1, x1, YELLOW);
			}
			pk = pk + 2 * dy - 2 * dx;
		}
	}
}*/

void ap_lite() {
  int reading_in; // the raw sensor reading AFTER being converted to inches
  int r; // sensor reading, with respect to range?
  float F; // Force 
  float delta; // the change in velocity
  float delta_vx, delta_vy; // change in velocity in each direction
  float w; // Angle of the robot to turn
  float theta; // The sensor angle
  float theta_new;

  // Power and speed are defined as a percentage of the maximum speed (0-1 inclusive)
  int power_left = 0;
  int power_right = 0;
  float STEP = 1.0; // step size of the robot
  float mass = 1.0; // mass of the robot (makes math easier)
  float FR = 0.5; // Friction
  float Fx = 100.0; // attractive goal force in x direction
  float Fy = 0.0; // robot does not move side-ways hence it's 0
  float v = currentVelocity; // current velocity, initial value is 70%
  float vx = FR * v; // velocity drops with friction
  float vy = 0; // no side-ways velocity

  // Changable settings
  float alpha = 1; // decides the amount to turn
  int MAX_SPEED = 60; // maximum power supply to motors 0-100 (converted later)
  int RANGE = 30; // reactive distance to an obstacle
  // Changing these values changes the repulsive force generated by each set of sensors
  float kmid = 7.0; // Hooke's law constant for two middle sensors
  float kside = 5.0; //Hooke's law constant for two outside sensors

  // for (all current sensors)
  for (int i = 0; i < 4; i++) {
    // Algorithm calls for the reading to be converted to inches.
    // Member function "readValue()" already does this.
    // "readValue()" also already filters for low readings.
    reading_in = sensor[i].readValue();
    theta = sensor_angle[i];

    r = RANGE - reading_in;
    if (r < 0) {
      // No obstacles seen
      r = 0;
    }

    // If we are reading from the middle sensors
    if (i == 1 || i == 2) {
      // compute force from the two middle sensors
      F = kmid * r; 
    }
    else {
      // compute force from the two out side sensors
      F = kside * r;
    }

    Fx = Fx - (F * cos(theta)); // Repulsive x component 
    Fy = Fy - (F * sin(theta)); // Repulsive y component    
  }

  delta_vx = STEP * Fx / mass; // change in velocity in x direction
  delta_vy = STEP * Fy / mass; // change in velocity in y direction

  vx += delta_vx; // add to velocity in x direction
  vy += delta_vy; // add to velocity in y direction

  v = sqrt(vx * vx + vy * vy); // current velocity

  delta = atan2(delta_vy, delta_vx); // direction of change in velocity
  w = turn_function(delta); // angle of the robot turn

  currentVelocity = v; // reset current velocity

  theta_new = atan2(vy, vx); // robot moves in first or second quadrant

  if ((-PI / 2.0 <= theta_new) && (theta_new <= PI/2.0)) {
    power_right = (int)(v + v * alpha * w); // power to right motor
    power_left = (int)(v - v * alpha * w); // power to left motor

    // proportionally cap the motor power
    // convert percent speed to integer for comparison
    if (power_right > MAX_SPEED || (int)robot.speedLeft()*100 > MAX_SPEED) {
      if (power_right >= power_left) {
        power_left = MAX_SPEED * power_left / power_right;
        power_right = MAX_SPEED;
      }
      else {
        power_right = MAX_SPEED * power_right / power_left;
        power_left = MAX_SPEED;
      }
    }
  }

  // If power is negative make it 0
  // Change this if you want the wheels to go backwards
  // make sure to add compatbility in the robot controller if you do so
  if (power_left < 0) {
    power_left = 0;
  }
  if (power_right < 0) {
    power_right = 0;
  }

  // Convert int speed to percentage
  Serial.print("L: ");
  Serial.println(power_left);
  Serial.print("R: ");
  Serial.println(power_right);
  robot.left((float)power_left/100);
  robot.right((float)power_right/100);  
}

// Return the angle to turn in radians
float turn_function(float angle) {
  float angle_rad = angle;

  // // robot moving to the first quadrant
  // if ((0 < angle) && (angle <= PI / 2.0)) {
  //   angle_rad = (PI / 2.0) - angle;
  // }
  // robot moving to the second quadrant
  if ((PI / 2.0 < angle) && (angle <= PI)) {
    angle_rad = PI - angle;
  }
  // robot moving to the third quadrant  
  if ((-PI < angle) && (angle <= -PI / 2.0)) {
    angle_rad = -PI - angle; //only used in backward move
  }
  // // robot moving to the fourth quadrant
  // if ((-PI / 2.0 < angle) && (angle <= 0)) {
  //   angle_rad = (-PI / 2.0) - angle;
  // }
  return angle_rad;
}

void test_function() {
  robot.stop();
  robot.right();
  delay(5000);

  robot.stop();
  robot.left();
  delay(5000);
  robot.forward();
  robot.stop();
  delay(5000);

}